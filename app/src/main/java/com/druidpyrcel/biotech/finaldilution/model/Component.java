package com.druidpyrcel.biotech.finaldilution.model;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table "COMPONENT".
 */
public class Component {

    private Boolean fromStock;
    /**
     * Not-null value.
     */
    private String solutionName;
    /**
     * Not-null value.
     */
    private String compoundShortName;
    private long desConcId;
    private Long availConcId;

    /**
     * Used to resolve relations
     */
    private transient DaoSession daoSession;

    /**
     * Used for active entity operations.
     */
    private transient ComponentDao myDao;

    private Solution solution;
    private String solution__resolvedKey;

    private Compound compound;
    private String compound__resolvedKey;

    private Concentration desiredConcentration;
    private Long desiredConcentration__resolvedKey;

    private Concentration availableConcentration;
    private Long availableConcentration__resolvedKey;


    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public Component() {
    }

    public Component(Boolean fromStock, String solutionName, String compoundShortName, long desConcId, Long availConcId) {
        this.fromStock = fromStock;
        this.solutionName = solutionName;
        this.compoundShortName = compoundShortName;
        this.desConcId = desConcId;
        this.availConcId = availConcId;
    }

    /**
     * called by internal mechanisms, do not call yourself.
     */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getComponentDao() : null;
    }

    public Boolean getFromStock() {
        return fromStock;
    }

    public void setFromStock(Boolean fromStock) {
        this.fromStock = fromStock;
    }

    /**
     * Not-null value.
     */
    public String getSolutionName() {
        return solutionName;
    }

    /**
     * Not-null value; ensure this value is available before it is saved to the database.
     */
    public void setSolutionName(String solutionName) {
        this.solutionName = solutionName;
    }

    /**
     * Not-null value.
     */
    public String getCompoundShortName() {
        return compoundShortName;
    }

    /**
     * Not-null value; ensure this value is available before it is saved to the database.
     */
    public void setCompoundShortName(String compoundShortName) {
        this.compoundShortName = compoundShortName;
    }

    public long getDesConcId() {
        return desConcId;
    }

    public void setDesConcId(long desConcId) {
        this.desConcId = desConcId;
    }

    public Long getAvailConcId() {
        return availConcId;
    }

    public void setAvailConcId(Long availConcId) {
        this.availConcId = availConcId;
    }

    /**
     * To-one relationship, resolved on first access.
     */
    public Solution getSolution() {
        String __key = this.solutionName;
        if (solution__resolvedKey == null || solution__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SolutionDao targetDao = daoSession.getSolutionDao();
            Solution solutionNew = targetDao.load(__key);
            synchronized (this) {
                solution = solutionNew;
                solution__resolvedKey = __key;
            }
        }
        return solution;
    }

    public void setSolution(Solution solution) {
        if (solution == null) {
            throw new DaoException("To-one property 'solutionName' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.solution = solution;
            solutionName = solution.getName();
            solution__resolvedKey = solutionName;
        }
    }

    /**
     * To-one relationship, resolved on first access.
     */
    public Compound getCompound() {
        String __key = this.compoundShortName;
        if (compound__resolvedKey == null || compound__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            CompoundDao targetDao = daoSession.getCompoundDao();
            Compound compoundNew = targetDao.load(__key);
            synchronized (this) {
                compound = compoundNew;
                compound__resolvedKey = __key;
            }
        }
        return compound;
    }

    public void setCompound(Compound compound) {
        if (compound == null) {
            throw new DaoException("To-one property 'compoundShortName' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.compound = compound;
            compoundShortName = compound.getShortName();
            compound__resolvedKey = compoundShortName;
        }
    }

    /**
     * To-one relationship, resolved on first access.
     */
    public Concentration getDesiredConcentration() {
        long __key = this.desConcId;
        if (desiredConcentration__resolvedKey == null || !desiredConcentration__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ConcentrationDao targetDao = daoSession.getConcentrationDao();
            Concentration desiredConcentrationNew = targetDao.load(__key);
            synchronized (this) {
                desiredConcentration = desiredConcentrationNew;
                desiredConcentration__resolvedKey = __key;
            }
        }
        return desiredConcentration;
    }

    public void setDesiredConcentration(Concentration desiredConcentration) {
        if (desiredConcentration == null) {
            throw new DaoException("To-one property 'desConcId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.desiredConcentration = desiredConcentration;
            desConcId = desiredConcentration.getId();
            desiredConcentration__resolvedKey = desConcId;
        }
    }

    /**
     * To-one relationship, resolved on first access.
     */
    public Concentration getAvailableConcentration() {
        Long __key = this.availConcId;
        if (availableConcentration__resolvedKey == null || !availableConcentration__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ConcentrationDao targetDao = daoSession.getConcentrationDao();
            Concentration availableConcentrationNew = targetDao.load(__key);
            synchronized (this) {
                availableConcentration = availableConcentrationNew;
                availableConcentration__resolvedKey = __key;
            }
        }
        return availableConcentration;
    }

    public void setAvailableConcentration(Concentration availableConcentration) {
        synchronized (this) {
            this.availableConcentration = availableConcentration;
            availConcId = availableConcentration == null ? null : availableConcentration.getId();
            availableConcentration__resolvedKey = availConcId;
        }
    }

    /**
     * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context.
     */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.delete(this);
    }

    /**
     * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context.
     */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.update(this);
    }

    /**
     * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context.
     */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here

    public String getAmountString(double volume) {

        double amount = getQuantity(volume);
        StringBuilder niceOutput = new StringBuilder(200);
        niceOutput.append(compound.getShortName());
        niceOutput.append(" : ");
        if (amount > 1) {
            niceOutput.append(String.format("%1$,.3f", amount));
            if (fromStock) {
                niceOutput.append(" ml");
            } else {
                niceOutput.append(" g");
            }
        } else {
            niceOutput.append(String.format("%1$,.1f", amount * 1000));
            if (fromStock) {
                niceOutput.append(" ul");
            } else {
                niceOutput.append(" mg");
            }
        }
        return niceOutput.toString();
    }

    public double getQuantity(double volume) {
        if (fromStock) {
            return calcVolumeForDesiredMass(calcDesiredMass(volume));
        } else {
            return calcDesiredMass(volume);
        }
    }

    /**
     * Calculate desired mass depending on desired concentration
     *
     * @param volume - volume[ml] of the final solution
     * @return - desired mass[g]
     */
    private double calcDesiredMass(double volume) {

        double c = desiredConcentration.getAmount();
        double M = compound.getMolarMass();
        switch (desiredConcentration.getType()) {
            case PERCENTAGE:
                return c * volume / 100;
            case MOLAR:
            default:
                return c * volume * M / 1000;
            case MILIMOLAR:
                return c * volume * M / 1000 / 1000;
            case MILIGRAM_PER_MILLILITER:
                return c * volume / 1000;
        }
    }

    /**
     * Calculate component volume using calculated desired mass
     *
     * @param mass - mass[g] required in final solution
     * @return - volume[ml] of compound to be taken
     */
    private double calcVolumeForDesiredMass(double mass) {

        double c = availableConcentration.getAmount();
        double M = compound.getMolarMass();
        switch (availableConcentration.getType()) {
            case PERCENTAGE:
                return mass / c * 100;
            case MOLAR:
            default:
                return mass / M / c * 1000;
            case MILIMOLAR:
                return mass / M / c * 1000 * 1000;
            case MILIGRAM_PER_MILLILITER:
                return mass / c * 1000;
        }
    }
    // KEEP METHODS END

}
